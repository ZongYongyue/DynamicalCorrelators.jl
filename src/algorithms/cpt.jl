"""
    Perioder{P<:AbstractVector{<:Integer}, T<:AbstractArray{P}, S<:AbstractArray{P}, C<:AbstractVector{<:Tuple}}

The information needed in performing periodic procedure. 
"""
struct Perioder{P<:AbstractVector{<:Integer}, T<:AbstractArray{P}, S<:AbstractArray{P}, C<:AbstractVector{<:Tuple}}
    map₁::T
    map₂::S
    channels::C
end 

"""
    Perioder(unitcell::QLattice, cluster::QLattice, table::Table)

Obtain the periodic information from the lattice system.

WARNING : User should ensure that the cluster you choosed is compatible with the lattice generated by the unitcell you input and the unitcell you input should be enclosed in the cluster you choosed sharing an original point with the cluster.
"""
function Perioder(unitcell::QLattice, cluster::QLattice, table::Table)
    @assert !isempty(unitcell.vectors) "the vectors in unitcell cannot be empty !"
    seq = sort(collect(keys(table)), by = x -> table[x])
    nspin, norbi, channels = sort(collect(Set(key[1] for key in seq))), sort(collect(Set(key[3] for key in seq))), Vector{Tuple{Vector{Int64},Vector{Int64}}}()
    map₁ = [filter(k -> nspin[i]==seq[k][1]&&norbi[j]==seq[k][3], 1:length(seq)) for i in eachindex(nspin), j in eachindex(norbi)]
    map₂ = [filter(j -> issubordinate(cluster.coordinates[:,j]-unitcell.coordinates[:,i], unitcell.vectors), 1:length(cluster)) for i in 1:length(unitcell)]
    for i in 1:size(map₁, 1), j in 1:size(map₁, 2), u in 1:size(map₁, 1), v in 1:size(map₁, 2) 
        push!(channels, ([i, j], [u, v]))
    end
    return Perioder(map₁, map₂, channels)
end


"""
    CPT{L<:QLattice, G<:EDSolver, P<:Perioder} 

CPT method for a quantum lattice system.
"""
struct CPT{L<:QtLattice, C<:QLattice, G<:AbstractArray, P<:Perioder}
    unitcell::L
    cluster::C
    origigenerator::OperatorGenerator
    refergenerator::OperatorGenerator
    gfrw::G
    perioder::P
end


function CPT(
            unitcell::QLattice, 
            cluster::QLattice, 
            hilbert::Hilbert, 
            origiterms::Tuple{Vararg{Term}}, 
            referterms::Tuple{Vararg{Term}}, 
            gfrw::AbstractArray{ComplexF64, 3}; 
            neighbors::Union{Nothing, Int, Neighbors}=nothing)
    table = Table(hilbert, OperatorIndexToTuple(:spin, :site, :orbital))
    isnothing(neighbors) && (neighbors = maximum(term->term.bondkind, origiterms))
    origibonds = bonds(cluster, neighbors)
    referbonds = filter(bond -> isintracell(bond), origibonds)
    perioder = Perioder(unitcell, cluster, table) 
    origigenerator, refergenerator = OperatorGenerator(origibonds, hilbert, origiterms), OperatorGenerator(referbonds, hilbert, referterms)
    return CPT(unitcell, cluster, origigenerator, refergenerator, gfrw, perioder, nothing)
end

"""
    origiQuadraticTerms!(normal::Bool, om::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector,k::AbstractVector)

Calculate the Hamiltonian's quadratic terms of the original system.
"""
function origiQuadraticTerms!(normal::Bool, om::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector,k::AbstractVector)
    !normal&&(pm = copy(om))
    for i in eachindex(oops)
        seq₁, seq₂, n₁, n₂ = oopsseqs[i][1], oopsseqs[i][2], oopsseqs[i][3], oopsseqs[i][4]
        phase = exp(im*dot(k, icoordinate(oops[i])))
        om[seq₁, seq₂] += oops[i].value*phase
        !normal&&(n₁==2&&n₂==1)&&(pm[seq₁, seq₂] += oops[i].value*(phase'))
    end
    if !normal
        om[Vector(1:(size(om,1)÷2)), Vector(1:(size(om,1)÷2))] /= 2
        om[Vector((size(om,1)÷2+1):size(om,1)), Vector((size(om,1)÷2+1):size(om,1))] = -transpose(pm[Vector(1:(size(om,1)÷2)), Vector(1:(size(om,1)÷2))])/2
        om = 2om
    end
    return om
end

"""
    referQuadraticTerms(normal::Bool, rops::AbstractVector, rm::AbstractMatrix, table::Table)
    
Calculate the Hamiltonian's quadratic terms of the reference system.
"""
function referQuadraticTerms(normal::Bool, rops::AbstractVector, rm::AbstractMatrix, table::Table)
    for rop in rops 
        rop[1].index.internal.nambu==2 ? seq₁=table[rop[1].index'] : seq₁=(table[rop[1].index]+length(table))
        rop[2].index.internal.nambu==1 ? seq₂=table[rop[2].index] : seq₂=(table[rop[2].index']+length(table))
        rm[seq₁, seq₂] += rop.value
    end
    if !normal
        rm[Vector(1:length(table)),Vector(1:length(table))] /= 2
        rm[Vector(length(table)+1:2*length(table)),Vector(length(table)+1:2*length(table))] = -transpose(rm[Vector(1:length(table)),Vector(1:length(table))])
        rm = 2rm
    end
    return rm
end

"""
    seqs(oops::AbstractVector, table::Table)

The index's sequences of original system operators.
"""
function seqs(oops::AbstractVector, table::Table)
    seqs = [zeros(Int, 2) for _ in 1:length(oops)]
    for i in eachindex(oops)
        oops[i][1].index.internal.nambu==2 ? seq₁=table[oops[i][1].index'] : seq₁=(table[oops[i][1].index]+length(table))
        oops[i][2].index.internal.nambu==1 ? seq₂=table[oops[i][2].index] : seq₂=(table[oops[i][2].index']+length(table))
        seqs[i] = [seq₁, seq₂, oops[i][1].index.internal.nambu, oops[i][2].index.internal.nambu]
    end
    return seqs
end

"""
    CPTcore(cgfm::AbstractMatrix, vm::AbstractMatrix)

The calculating core of the CPT method.
"""
function CPTcore(cgfm::AbstractMatrix, vm::AbstractMatrix)
    result = Matrix{ComplexF64}(I, size(vm)...)
    return cgfm*inv(mul!(result, vm, cgfm, -1, 1))
end

"""
    perGreenFunction(normal::Bool, GFm::AbstractMatrix, k::AbstractVector, perioder::Perioder, cluster::QLattice)

Perform the periodic procedure to cluster Green function, obtatined periodization Green function with respect to whole k-space.
"""
function perGreenFunction(normal::Bool, GFm::AbstractMatrix, k::AbstractVector, perioder::Perioder, cluster::QLattice)
    N₁, N₂, P = length(perioder.map₁), length(perioder.map₂), size(GFm, 1)÷2
    normal ? (V = 1) : (V = 4)
    normal ? (bgfv = [GFm]) : (bgfv = [GFm[1:P,1:P], GFm[1:P,(P+1):2P], GFm[(P+1):2P, 1:P], GFm[(P+1):2P, (P+1):2P]])
    gfvs = [Vector{Matrix{ComplexF64}}(undef, length(perioder.channels)) for _ in 1:V]
    pm = periodmatrix(cluster.coordinates, k)
    for i in 1:V
        for j in eachindex(perioder.channels)
            gfvs[i][j] = periodsum(perioder.map₂, bgfv[i][perioder.map₁[perioder.channels[j][1]...], perioder.map₁[perioder.channels[j][2]...]].*pm, N₂, size(cluster.coordinates,2))
        end
    end
    gfmv = [reshapematrix(N₁, N₂, gfv) for gfv in gfvs]
    normal ? (gfm = gfmv[1]) : (gfm = [gfmv[1] gfmv[2]; gfmv[3] gfmv[4]])
    return gfm
end

function periodmatrix(coordinates::AbstractMatrix, k::AbstractVector)
    L = size(coordinates,2)
    pm = Matrix{ComplexF64}(undef, L, L)
    for i in 1:L, j in 1:L
        @views ra, rb = coordinates[:, i], coordinates[:, j]
        pm[i, j] = exp(-im*dot(k, (ra - rb)))
    end
    return pm
end
function periodsum(map₂::AbstractVector, lgfm::AbstractMatrix, N::Int, L::Int)
    pgfm = Matrix{ComplexF64}(undef, N, N)
    for m in 1:N, n in 1:N
        @views cmap₂, hmap₂ = map₂[m], map₂[n]
        pgfm[m, n] = (N/L)*sum(lgfm[cmap₂, hmap₂])
    end
    return pgfm
end
function reshapematrix(N₁::Int, N₂::Int, gfv)
    gfm = Matrix{ComplexF64}(undef, N₁*N₂,  N₁*N₂)
    gfmm = reshape(gfv, (N₁, N₁))
    for i in 1:N₁, j in 1:N₁
        for u in 1:N₂, v in 1:N₂
            gfm[(i-1)*N₂ + u, (j-1)*N₂ + v] = gfmm[i, j][u, v]
        end
    end
    return gfm
end

"""
    GreenFunctionPath(normal::Bool, om::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector, rm::AbstractMatrix, perioder::Perioder, cluster::QLattice, k_path::Union{AbstractVector, ReciprocalSpace}, CGFm::AbstractMatrix)

Give the Green function of a certain path or area in k-space with respect to a certain energy.
"""
function GreenFunctionPath(normal::Bool, om::AbstractMatrix, oops::AbstractVector, oopsseqs::AbstractVector, rm::AbstractMatrix, perioder::Perioder, cluster::QLattice, k_path::Union{AbstractVector, ReciprocalSpace}, CGFm::AbstractMatrix; loc::Union{Nothing, AbstractVector}=nothing)
    gfpath = Vector{Matrix{ComplexF64}}(undef, length(k_path))
    if isnothing(loc)
        for i in eachindex(k_path)
            dest = copy(om)
            Vm = origiQuadraticTerms!(normal, dest, oops, oopsseqs, k_path[i]) - rm
            gfpath[i] = perGreenFunction(normal, CPTcore(CGFm, Vm), k_path[i], perioder, cluster)
        end
    else
        for i in eachindex(k_path)
            dest = copy(om)
            Vm = origiQuadraticTerms!(normal, dest, oops, oopsseqs, k_path[i]) - rm
            gfpath[i] = CPTcore(CGFm, Vm)[loc, loc]
        end
    end
    return gfpath
end 

"""
    singleParticleGreenFunction(sym::Symbol, cpt::CPT, k_path::Union{AbstractVector, ReciprocalSpace}, ω_range::Union{AbstractVector,AbstractRange}; μ::Real=0.0,  dstr::Bool=false)

The single particle Green function in k-ω space.
"""
function singleParticleGreenFunction(cpt::CPT, k_path::Union{AbstractVector, ReciprocalSpace}; mthreads::Integer=Threads.nthreads(), loc::Union{Nothing, AbstractVector}=nothing)
    oops, rops = filter(op -> length(op) == 2, collect(expand(cpt.origigenerator))), filter(op -> length(op) == 2, collect(expand(cpt.refergenerator)))
    R, N = isempty(filter(op -> op.id[1].index.internal.nambu==op.id[2].index.internal.nambu, collect(rops))), length(cpt.refergenerator.table)
    R ? N=N : N=2*N
    oopsseqs = seqs(oops, cpt.origigenerator.table)
    rm = referQuadraticTerms(R, rops, zeros(ComplexF64, N, N), cpt.refergenerator.table)
    gfpv = Vector(undef, length(ω_range))
    if mthreads == 1
        for i in 1:size(cpt.gfrw, 3)
            gfpv[i] = GreenFunctionPath(R, zeros(ComplexF64, N, N), oops, oopsseqs, rm, cpt.perioder, cpt.cluster, k_path, cpt.gfrw[:,:,i]; loc=loc)
        end
    else
        idx = Threads.Atomic{Int}(1)
        n = size(cpt.gfrw, 3)
        Threads.@sync for _ in 1:mthreads
            Threads.@spawn while true
                i = Threads.atomic_add!(idx, 1)  
                i > n && break  
                gfpv[i] = GreenFunctionPath(R, zeros(ComplexF64, N, N), oops, oopsseqs, rm, cpt.perioder, cpt.cluster, k_path, cpt.gfrw[:,:,i]; loc=loc)
            end
        end
    end
    return gfpv
end

function singleParticleGreenFunction(cpt::CPT, k_path::Union{AbstractVector, ReciprocalSpace}; fsid::Int, loc::Union{Nothing, AbstractVector}=nothing)
    oops, rops = filter(op -> length(op) == 2, collect(expand(cpt.origigenerator))), filter(op -> length(op) == 2, collect(expand(cpt.refergenerator)))
    R, N = isempty(filter(op -> op.id[1].index.internal.nambu==op.id[2].index.internal.nambu, collect(rops))), length(cpt.refergenerator.table)
    R ? N=N : N=2*N
    oopsseqs = seqs(oops, cpt.origigenerator.table)
    rm = referQuadraticTerms(R, rops, zeros(ComplexF64, N, N), cpt.refergenerator.table)
    gfpv = Vector(undef, 1)
    gfpv[1] = GreenFunctionPath(R, zeros(ComplexF64, N, N), oops, oopsseqs, rm, cpt.perioder, cpt.cluster, k_path, cpt.gfrw[:,:,fsid]; loc=loc)
    return gfpv
end

"""
    spectrum(gfpathv::AbstractVector)

The spectrum of the single particle Green function.
"""
function spectrum(gfpathv::AbstractVector; select::AbstractVector=Vector(1:size(gfpathv[1][1],2)))
    A = zeros(Float64, length(gfpathv), length(gfpathv[1]))
        for i in eachindex(gfpathv)
            for j in eachindex(gfpathv[i])
                A[i, j] = (-1/π) * (tr(gfpathv[i][j][select, select])).im
            end
        end
        return A
end

"""
    Density of states
"""
function densityofstates(gfpathv::AbstractVector; select::AbstractVector=Vector(1:size(gfpathv[1][1],2)))
    A = zeros(Float64, length(gfpathv))
    for i in eachindex(gfpathv)
        for j in eachindex(gfpathv[i])
            A[i] += (-1/π) * (tr(gfpathv[i][j][select, select])).im
        end
    end
    return A/length(gfpathv[1])
end
