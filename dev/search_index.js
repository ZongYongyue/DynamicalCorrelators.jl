var documenterSearchIndex = {"docs":
[{"location":"api/models/#Models-and-Lattices","page":"Models & Lattices","title":"Models & Lattices","text":"","category":"section"},{"location":"api/models/#Lattice-Types","page":"Models & Lattices","title":"Lattice Types","text":"","category":"section"},{"location":"api/models/#Lattice-Utilities","page":"Models & Lattices","title":"Lattice Utilities","text":"","category":"section"},{"location":"api/models/#Hamiltonians","page":"Models & Lattices","title":"Hamiltonians","text":"","category":"section"},{"location":"api/models/#DynamicalCorrelators.CustomLattice","page":"Models & Lattices","title":"DynamicalCorrelators.CustomLattice","text":"abstract type CustomLattice end\n\nAbstract supertype for all custom lattice structures used in DynamicalCorrelators.jl.\n\nSubtypes must provide fields lattice (a QLattice from QuantumLattices) and indices (a nested array mapping each lattice site to its orbital-resolved MPS site indices).\n\n\n\n\n\n","category":"type"},{"location":"api/models/#DynamicalCorrelators.BilayerSquare","page":"Models & Lattices","title":"DynamicalCorrelators.BilayerSquare","text":"BilayerSquare{T,U,L} <: CustomLattice\n\nA bilayer square lattice with two layers stacked along the z-direction.\n\nFields\n\nW::T: width of the lattice (number of sites along x).\nL::T: length of the lattice (number of sites along y).\nunitcell::U: the two-site unit cell (one site per layer).\nlattice::L: the full lattice generated from the unit cell.\nindices::AbstractArray: mapping from lattice site index to MPS site indices, grouped by orbital.\n\n\n\n\n\n","category":"type"},{"location":"api/models/#DynamicalCorrelators.Square","page":"Models & Lattices","title":"DynamicalCorrelators.Square","text":"Square{T,U,L} <: CustomLattice\n\nA 2D square lattice.\n\nFields\n\nW::T: width of the lattice.\nL::T: length of the lattice.\nunitcell::U: the single-site unit cell.\nlattice::L: the full lattice.\nindices: mapping from lattice site to MPS site indices.\n\n\n\n\n\n","category":"type"},{"location":"api/models/#DynamicalCorrelators.Custom","page":"Models & Lattices","title":"DynamicalCorrelators.Custom","text":"Custom{T,L} <: CustomLattice\n\nA lattice wrapper for arbitrary QLattice objects from QuantumLattices.\n\nFields\n\nlattice::L: the underlying QuantumLattices lattice.\nindices: mapping from lattice site to MPS site indices.\n\n\n\n\n\n","category":"type"},{"location":"api/models/#DynamicalCorrelators.twosite_bonds","page":"Models & Lattices","title":"DynamicalCorrelators.twosite_bonds","text":"twosite_bonds(customlattice::CustomLattice, a::Integer, b::Integer; intralayer=true, neighbors=Neighbors(1=>1))\n\nReturn an array of (site_a, site_b) pairs representing two-site bonds on the lattice.\n\nFor 3D lattices (bilayer), intralayer controls whether to select bonds within the same layer (true) or between layers (false). Orbital indices a and b select which orbital on each site to include.\n\nArguments\n\ncustomlattice: the lattice structure.\na, b: orbital indices for the two sites of each bond.\nintralayer: select intralayer (true) or interlayer (false) bonds (only relevant for 3D lattices).\nneighbors: neighbor specification from QuantumLattices.\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.onesite_bonds","page":"Models & Lattices","title":"DynamicalCorrelators.onesite_bonds","text":"onesite_bonds(customlattice::CustomLattice, a::Integer, b::Integer)\n\nReturn an array of (site_a, site_b) tuples for on-site (two-orbital) terms, where a and b are the orbital indices on the same lattice site.\n\n\n\n\n\nonesite_bonds(customlattice::CustomLattice, a::Integer)\n\nReturn an array of single-element tuples (site_a,) for on-site (single-orbital) terms.\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.find_position","page":"Models & Lattices","title":"DynamicalCorrelators.find_position","text":"find_position(indices, target::Integer)\n\nFind the lattice site index that contains the MPS site index target. Returns nothing if not found.\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.snake_2D","page":"Models & Lattices","title":"DynamicalCorrelators.snake_2D","text":"snake_2D(directions, orders)\n\nGenerate a 2D lattice path (snake-like) from a sequence of directional steps.\n\nArguments\n\ndirections: array of direction vectors (e.g., [[1,0], [0,1]]).\norders: array of integers specifying which direction to take at each step. Positive values move forward, negative values move backward along that direction.\n\nReturns\n\nA vector of 2D coordinates tracing the path starting from [0, 0].\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.kitaev_bonds","page":"Models & Lattices","title":"DynamicalCorrelators.kitaev_bonds","text":"kitaev_bonds(directions, lattice)\n\nClassify nearest-neighbor bonds of a lattice into three groups based on their alignment with three given directions (for Kitaev-type models).\n\nEach bond is assigned to the direction whose unit vector is parallel to the bond vector (using the dot product criterion |a·b| ≈ |a||b|).\n\nArguments\n\ndirections: array of 3 direction vectors defining x-, y-, z-type bonds.\nlattice: a QLattice from QuantumLattices.\n\nReturns\n\nThree arrays of (site_i, site_j) tuples, one for each direction.\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.hubbard","page":"Models & Lattices","title":"DynamicalCorrelators.hubbard","text":"hubbard(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}, lattice=InfiniteChain(1); t=1.0, U=1.0, μ=0.0, filling=(1,1))\nfℤ₂ × U(1) × U(1) single-band Hubbard model\n\n\n\n\n\nhubbard(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}, lattice=InfiniteChain(1); t=1.0, U=1.0, μ=0.0, filling=(1,1))\nfℤ₂ × SU(2) × U(1) single-band Hubbard model\n\n\n\n\n\nhubbard(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}, \n                lattice::CustomLattice; kwargs...)\nfℤ₂ × SU(2) × U(1)  Hubbard model\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.extended_hubbard","page":"Models & Lattices","title":"DynamicalCorrelators.extended_hubbard","text":"extended_hubbard(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}, lattice=InfiniteChain(1); t=1.0, U=1.0, μ=0.0, filling=(1,1))\nfℤ₂ × SU(2) × U(1) single-band Hubbard model\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.hubbard_bilayer_2band","page":"Models & Lattices","title":"DynamicalCorrelators.hubbard_bilayer_2band","text":"hubbard_bilayer_2band(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}, \n                lattice=BilayerSquare(2, 2; norbit=2); kwargs...)\nfℤ₂ × SU(2) × U(1) two-band bilayer square lattice Hubbard model\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.kitaev_hubbard","page":"Models & Lattices","title":"DynamicalCorrelators.kitaev_hubbard","text":"kitaev_hubbard(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}, lattice=FiniteChain(1); t=1.0, tz=0.0, U=1.0, μ=0.0, filling=(1,1))\n\nConstruct a fℤ₂ × U(1) × U(1) 1d-Chain Kitaev-Hubbard model without pairing terms.\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.heisenberg_model","page":"Models & Lattices","title":"DynamicalCorrelators.heisenberg_model","text":"heisenberg_model(elt::Type{<:Number}, ::Type{SU2Irrep}, lattice=FiniteChain(1); J=1.0)\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.JKGGp_model","page":"Models & Lattices","title":"DynamicalCorrelators.JKGGp_model","text":"JKGGp_model(L, x_indices, y_indices, z_indices; spin=1//2, J=1, K=0, G=0, Gp=0)\n\nConstruct a JKΓΓ' (Kitaev-Heisenberg-Gamma) spin model Hamiltonian without symmetry constraints.\n\nThe Hamiltonian on each bond type (x, y, z) is: H_gamma = (J+K) S^gamma_i S^gamma_j + J sum_alpha neq gamma S^alpha_i S^alpha_j + Gamma(ldots) + Gamma(ldots)\n\nArguments\n\nL: total number of sites.\nx_indices, y_indices, z_indices: arrays of (site_i, site_j) tuples for x-, y-, z-type bonds.\nspin: spin quantum number (default: 1/2).\nJ: Heisenberg coupling.\nK: Kitaev coupling.\nG (Γ): off-diagonal symmetric exchange.\nGp (Γ'): off-diagonal symmetric exchange (primed).\n\n\n\n\n\n","category":"function"},{"location":"api/models/#DynamicalCorrelators.hamiltonian","page":"Models & Lattices","title":"DynamicalCorrelators.hamiltonian","text":"hamiltonian(terms, lattice, hilbert; neighbors=nothing, filling=(1,1))\n\nConstruct a FiniteMPOHamiltonian from QuantumLattices Terms on a given lattice with Hilbert space hilbert. Uses fℤ₂ × U(1) × U(1) symmetry.\n\nArguments\n\nterms: tuple of Term objects (e.g., Hopping, Hubbard, Onsite).\nlattice: a Lattice from QuantumLattices.\nhilbert: the Hilbert space specification.\nneighbors: neighbor order. If nothing, inferred from terms.\nfilling: tuple (P, Q) defining the filling fraction.\n\n\n\n\n\nhamiltonian(operators::OperatorSet, len, filling)\n\nConvert a set of symbolic operators into a FiniteMPOHamiltonian with U(1)×U(1) symmetry. Each operator is converted to an MPO tensor via _convert_operator.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/dmrg/#Ground-State-with-DMRG","page":"Ground State with DMRG","title":"Ground State with DMRG","text":"This tutorial covers how to find the ground state of a quantum many-body system using DMRG.\n\nThe core DMRG algorithms are provided by MPSKit.jl. DynamicalCorrelators.jl provides convenience wrappers (dmrg2!, dmrg2_sweep!, idmrg2) that add progress logging, automatic file saving, and multi-sweep truncation management.","category":"section"},{"location":"tutorials/dmrg/#Standard-DMRG-via-MPSKit","page":"Ground State with DMRG","title":"Standard DMRG via MPSKit","text":"The simplest approach uses MPSKit's find_groundstate directly:\n\nusing TensorKit, MPSKit, DynamicalCorrelators\n\nfilling = (1, 1)\nH = hubbard(Float64, SU2Irrep, U1Irrep, FiniteChain(24); t=1, U=8, filling=filling)\nst = randFiniteMPS(ComplexF64, SU2Irrep, U1Irrep, 24; filling=filling)\n\ngs, envs, delta = find_groundstate(st, H, DMRG2(trscheme=trunctol(1e-6)))","category":"section"},{"location":"tutorials/dmrg/#Multi-sweep-DMRG-with-dmrg2!","page":"Ground State with DMRG","title":"Multi-sweep DMRG with dmrg2!","text":"For production calculations, dmrg2! wraps MPSKit's DMRG2 with automatic progress logging and JLD2 file saving after each sweep. It supports progressively increasing bond dimensions:\n\n# Gradually increase bond dimension: 128 → 256 → 512 → 1024\ntruncdims = [128, 256, 512, 1024]\n\ngs, envs, epsilon = dmrg2!(st, H, truncdims;\n    filename=\"dmrg_results.jld2\",\n    verbose=true\n)\n\nThis saves intermediate results to a JLD2 file after each sweep, allowing you to:\n\nResume calculations if they are interrupted\nMonitor convergence by checking energy at each bond dimension\nExtract the optimal state at any truncation level","category":"section"},{"location":"tutorials/dmrg/#Single-sweep-DMRG-with-dmrg2_sweep!","page":"Ground State with DMRG","title":"Single-sweep DMRG with dmrg2_sweep!","text":"For fine-grained control over individual sweeps:\n\n# Initialize convergence tracker\nepsilon = ones(Float64, length(st))\n\n# Run sweeps manually\nfor iter in 1:10\n    dmrg2_sweep!(iter, st, H, truncrank(1024), epsilon;\n        filename=\"dmrg_sweep.jld2\",\n        verbose=true\n    )\nend","category":"section"},{"location":"tutorials/dmrg/#Infinite-DMRG-with-idmrg2","page":"Ground State with DMRG","title":"Infinite DMRG with idmrg2","text":"For infinite systems (translation-invariant), idmrg2 wraps MPSKit's IDMRG/IDMRG2:\n\nH_inf = hubbard(Float64, SU2Irrep, U1Irrep, InfiniteChain(2); t=1, U=8, filling=filling)\nst_inf = randInfiniteMPS(ComplexF64, SU2Irrep, U1Irrep, 2; filling=filling)\n\ngs_inf, envs_inf, delta_inf = idmrg2(st_inf, H_inf;\n    filename=\"idmrg_results.jld2\",\n    verbose=true\n)","category":"section"},{"location":"tutorials/dmrg/#Tips-for-Production-Runs","page":"Ground State with DMRG","title":"Tips for Production Runs","text":"Use Float64 for DMRG, then convert to ComplexF64 for time evolution:\ngs_complex = complex(gs)\nSet MKL threads to 1 when using multi-process parallelism:\nusing MKL\nBLAS.set_num_threads(1)\nUse OhMyThreads for block-level parallelism in TensorKit:\nusing OhMyThreads\nTensorKit.with_blockscheduler(DynamicScheduler()) do\n    # DMRG code here\nend","category":"section"},{"location":"api/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"api/utilities/#Tensor-Operations","page":"Utilities","title":"Tensor Operations","text":"","category":"section"},{"location":"api/utilities/#Coordinate-Utilities","page":"Utilities","title":"Coordinate Utilities","text":"","category":"section"},{"location":"api/utilities/#DynamicalCorrelators.add_single_util_leg","page":"Utilities","title":"DynamicalCorrelators.add_single_util_leg","text":"add_single_util_leg(tensor::AbstractTensorMap)\n\nAdd a trivial (one-dimensional) utility leg to a tensor map to balance the number of codomain and domain legs. If codomain < domain, adds a leg to the codomain (left); if codomain > domain, adds a leg to the domain (right). This is needed when converting operators to MPO format.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#DynamicalCorrelators.contract_MPO","page":"Utilities","title":"DynamicalCorrelators.contract_MPO","text":"contract_MPO(mpo1::FiniteMPO, mpo2::FiniteMPO)\n\nVertically contract (fuse) two FiniteMPOs into a single FiniteMPO. The boundary tensors are handled separately with explicit fusion, while interior tensors use fuse_mul_mpo. The result is truncated with notrunc().\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#MPSKit.transfer_left","page":"Utilities","title":"MPSKit.transfer_left","text":"transfer_left(v, A, Ab)\n\nLeft transfer operation for a 4-leg boundary tensor v through an MPS tensor A and its conjugate Ab. Used in multi-site correlation function contractions where extra operator legs need to be propagated through the chain via braiding tensors (τ).\n\n\n\n\n\ntransfer_left(v, A, Ab)\n\nLeft transfer operation for a 3-leg boundary tensor v. See the 4-leg version above.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#DynamicalCorrelators.cart2polar","page":"Utilities","title":"DynamicalCorrelators.cart2polar","text":"cart2polar(point::AbstractArray) -> (r, θ, ϕ)\n\nConvert Cartesian coordinates to polar/spherical coordinates. For 2D points, returns (r, θ, π/2). For 3D points, returns (r, θ, ϕ).\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#DynamicalCorrelators.phase_by_polar","page":"Utilities","title":"DynamicalCorrelators.phase_by_polar","text":"phase_by_polar(theta, phi, phases)\n\nReturn a closure that maps a Bond to its phase factor based on its polar angle. Used to assign direction-dependent hopping amplitudes (e.g., d-wave pairing).\n\nArguments\n\ntheta: array of arrays of θ values for each phase group.\nphi: array of arrays of ϕ values for each phase group.\nphases: the phase factor to assign for each group.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#DynamicalCorrelators.sort_by_distance","page":"Utilities","title":"DynamicalCorrelators.sort_by_distance","text":"sort_by_distance(latt::CustomLattice, ij)\n\nGiven a flat array ij of site indices (first half = left sites, second half = right sites), compute all pairwise distances and return the site pairs sorted by distance.\n\nReturns (is, js, ds) where is[k]-js[k] is the k-th pair and ds[k] is its distance.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/spectral_functions/#Spectral-Functions","page":"Spectral Functions","title":"Spectral Functions","text":"This tutorial shows how to obtain momentum-frequency resolved spectral functions from real-space, real-time correlation functions via Fourier transforms.","category":"section"},{"location":"tutorials/spectral_functions/#Theory","page":"Spectral Functions","title":"Theory","text":"The spectral function is obtained from the double Fourier transform of the Green's function:\n\nG(k omega) = frac1(2pi)^2 int_0^t_mathrmend dt int_0^L dx  G(x t)  e^-i(kx - omega t)\n\nThe spectral function is then:\n\nA(k omega) = -frac1pi mathrmIm mathrmtr G(k omega)","category":"section"},{"location":"tutorials/spectral_functions/#Full-workflow","page":"Spectral Functions","title":"Full workflow","text":"using TensorKit, MPSKit, DynamicalCorrelators\n\n# 1. Compute ground state\nfilling = (1, 1)\nN = 48\nH = hubbard(Float64, SU2Irrep, U1Irrep, FiniteChain(N); t=1, U=8, filling=filling)\nst = randFiniteMPS(ComplexF64, SU2Irrep, U1Irrep, N; filling=filling)\ngs, _, _ = find_groundstate(st, H, DMRG2(trscheme=trunctol(1e-6)))\n\n# 2. Compute G(r, t)\ncp = e_plus(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\ncm = e_min(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\nts = 0:0.05:20\ngf_rt = dcorrelator(gs, H, (cp, cm); times=ts, trscheme=truncrank(200))\n\n# 3. Fourier transform to G(k, ω)\n# Define k-points and frequency range\nks = [[k] for k in range(-pi, pi, 100)]\nws = range(-10, 10, 500)\n\n# Site positions (1D chain)\nrs = [[Float64(i)] for i in 1:N]\n\n# Double Fourier transform with Gaussian broadening (η = 0.05)\ngf_kw = fourier_kw(gf_rt, rs, ts, ks, ws; broadentype=(0.05, \"G\"))\n\n# 4. Extract spectral function A(k, ω) = -Im(tr(G))/π\nA = -imag.(gf_kw) ./ π","category":"section"},{"location":"tutorials/spectral_functions/#Broadening-Options","page":"Spectral Functions","title":"Broadening Options","text":"Several broadening/windowing functions are available to suppress truncation artifacts:\n\nType Code Formula\nGaussian \"G\" e^-(eta t)^2\nLorentzian \"L\" ``e^{-\\eta\nBlackman \"B\" 042 - 05cos(2pi tT) + 008cos(4pi tT)\nParzen \"P\" Piecewise cubic taper\n\nUsage:\n\n# Gaussian broadening with η = 0.05\ngf_kw = fourier_kw(gf_rt, rs, ts, ks, ws; broadentype=(0.05, \"G\"))\n\n# Lorentzian broadening with η = 0.1\ngf_kw = fourier_kw(gf_rt, rs, ts, ks, ws; broadentype=(0.1, \"L\"))","category":"section"},{"location":"tutorials/spectral_functions/#Real-space-frequency-transform","page":"Spectral Functions","title":"Real-space frequency transform","text":"For computing the local density of states or real-space resolved spectral functions:\n\nws = range(-10, 10, 500)\ngf_rw = fourier_rw(gf_rt, ts, ws; broadentype=(0.05, \"G\"))","category":"section"},{"location":"tutorials/spectral_functions/#Static-Structure-Factor","page":"Spectral Functions","title":"Static Structure Factor","text":"For equal-time correlations, compute the static structure factor directly:\n\n# ss is the real-space correlation matrix ⟨S_a S_b⟩\nsf = static_structure_factor(ss, rs, ks)","category":"section"},{"location":"tutorials/spectral_functions/#Multi-orbital-Systems","page":"Spectral Functions","title":"Multi-orbital Systems","text":"For multi-orbital systems (e.g., bilayer), use the regroup parameter to specify orbital grouping:\n\n# 2 orbitals per site, 8 sites → indices [1,2], [3,4], ...\nregroup = [[2i-1, 2i] for i in 1:8]\ngf_kw = fourier_kw(gf_rt, rs, ts, ks, ws; regroup=regroup)","category":"section"},{"location":"api/states/#States","page":"States","title":"States","text":"","category":"section"},{"location":"api/states/#MPS-Type-Aliases","page":"States","title":"MPS Type Aliases","text":"","category":"section"},{"location":"api/states/#Charged-MPS","page":"States","title":"Charged MPS","text":"","category":"section"},{"location":"api/states/#Random-MPS","page":"States","title":"Random MPS","text":"","category":"section"},{"location":"api/states/#DynamicalCorrelators.FiniteNormalMPS","page":"States","title":"DynamicalCorrelators.FiniteNormalMPS","text":"const FiniteNormalMPS{C}\n\nType alias for a standard finite MPS with 2-leg physical tensors (virtual-physical; virtual). Used for zero-temperature ground states.\n\n\n\n\n\n","category":"type"},{"location":"api/states/#DynamicalCorrelators.FiniteSuperMPS","page":"States","title":"DynamicalCorrelators.FiniteSuperMPS","text":"const FiniteSuperMPS{C}\n\nType alias for a finite MPS with 3-leg physical tensors (virtual-physical-ancilla; virtual). Used for finite-temperature density matrix purification (thermofield double formalism).\n\n\n\n\n\n","category":"type"},{"location":"api/states/#DynamicalCorrelators.chargedMPS","page":"States","title":"DynamicalCorrelators.chargedMPS","text":"chargedMPS(operator::AbstractTensorMap, state::FiniteNormalMPS, site::Integer)\n\nApply a local operator at site to a normal MPS by constructing a charged MPO and contracting it with the state. Returns the resulting MPS (e.g., c†ᵢ|ψ⟩).\n\n\n\n\n\nchargedMPS(operator::AbstractTensorMap, state::FiniteNormalMPS, site₁::Integer, site₂::Integer)\n\nApply a two-site operator at site₁ and site₂ to a normal MPS.\n\n\n\n\n\nchargedMPS(op::AbstractTensorMap{B,S,1,2}, mps::FiniteSuperMPS, site::Integer)\n\nApply a (1,2)-leg operator (1 codomain, 2 domain legs) to a super MPS at site. This inserts the operator into the physical-ancilla leg structure of the purified state. For sites after the operator site, the tensor legs are rearranged via braiding (τ).\n\n\n\n\n\nchargedMPS(op::AbstractTensorMap{S,B,2,1}, mps::FiniteSuperMPS, site::Integer)\n\nApply a (2,1)-leg operator (2 codomain, 1 domain legs) to a super MPS at site. For sites before the operator site, the tensor legs are rearranged via braiding (τ).\n\n\n\n\n\nchargedMPS(op::AbstractTensorMap{S,B,1,1}, mps::FiniteSuperMPS, site::Integer)\n\nApply a (1,1)-leg operator (diagonal, charge-neutral) to a super MPS at site. Only the tensor at the operator site is modified; all other tensors remain unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/states/#DynamicalCorrelators.identityMPS","page":"States","title":"DynamicalCorrelators.identityMPS","text":"identityMPS(H::FiniteMPOHamiltonian)\n\nConstruct an identity MPS (purified infinite-temperature density matrix) from a Hamiltonian. Each site tensor is a BraidingTensor acting as an identity map on the physical space. This serves as the initial state for imaginary-time evolution to finite temperature.\n\n\n\n\n\n","category":"function"},{"location":"api/states/#DynamicalCorrelators.randFiniteMPS","page":"States","title":"DynamicalCorrelators.randFiniteMPS","text":"randFiniteMPS(elt, U1Irrep, U1Irrep, N; filling=(1,1), md=10, mz=nothing)\n\nCreate a random finite MPS with fℤ₂ × U(1) × U(1) symmetry (charge and spin conservation).\n\nArguments\n\nelt: element type (e.g., Float64, ComplexF64).\nN: number of sites.\nfilling: tuple (P, Q) defining the filling fraction P/Q. Requires N to be a multiple of 2Q.\nmd: bond dimension for each quantum number sector (default: 10).\nmz: maximum charge quantum number range. If nothing, determined from filling.\n\n\n\n\n\nrandFiniteMPS(elt, SU2Irrep, U1Irrep, N; filling=(1,1), md=10, mz=nothing)\n\nCreate a random finite MPS with fℤ₂ × SU(2) × U(1) symmetry (spin-rotation and charge conservation).\n\nArguments\n\nelt: element type.\nN: number of sites.\nfilling: tuple (P, Q) defining filling P/Q.\nmd: bond dimension per sector (default: 10).\nmz: maximum quantum number range. If nothing, determined from filling.\n\n\n\n\n\nrandFiniteMPS(elt, H::MPOHamiltonian; left=oneunit(...), right=oneunit(...))\n\nCreate a random finite MPS compatible with the given MPO Hamiltonian H. The virtual spaces are automatically inferred from the physical spaces and boundary conditions.\n\n\n\n\n\nrandFiniteMPS(elt, pspace, N; right=oneunit(pspace))\n\nCreate a random finite MPS with N sites, each having physical space pspace.\n\n\n\n\n\n","category":"function"},{"location":"api/states/#DynamicalCorrelators.randInfiniteMPS","page":"States","title":"DynamicalCorrelators.randInfiniteMPS","text":"randInfiniteMPS(elt, U1Irrep, U1Irrep, N; filling=(1,1), md=10, mz=nothing)\n\nCreate a random infinite MPS with fℤ₂ × U(1) × U(1) symmetry. Arguments are the same as randFiniteMPS for the U(1)×U(1) case.\n\n\n\n\n\nrandInfiniteMPS(elt, SU2Irrep, U1Irrep, N; filling=(1,1), md=10, mz=nothing)\n\nCreate a random infinite MPS with fℤ₂ × SU(2) × U(1) symmetry. Arguments are the same as randFiniteMPS for the SU(2)×U(1) case.\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"api/operators/#Fermionic-Operators","page":"Operators","title":"Fermionic Operators","text":"","category":"section"},{"location":"api/operators/#Spin-Operators","page":"Operators","title":"Spin Operators","text":"","category":"section"},{"location":"api/operators/#Interaction-Operators","page":"Operators","title":"Interaction Operators","text":"","category":"section"},{"location":"api/operators/#MPO-Construction","page":"Operators","title":"MPO Construction","text":"","category":"section"},{"location":"api/operators/#DynamicalCorrelators.fZ","page":"Operators","title":"DynamicalCorrelators.fZ","text":"fZ(operator::AbstractTensorMap)\nbraiding operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.e_plus","page":"Operators","title":"DynamicalCorrelators.e_plus","text":"e_plus(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; side=:L, spin=:up, filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) electron creation operator\n\n\n\n\n\ne_plus(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}; side=:L, filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) electron creation operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.e_min","page":"Operators","title":"DynamicalCorrelators.e_min","text":"e_min(particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector}; kwargs...)\ne_min(elt::Type{<:Number}, particle_symmetry::Type{U1Irrep}, spin_symmetry::Type{U1Irrep}; side=:L, spin=:up, filling=(1,1))\nfℤ₂ × U(1) × U(1) electron annihilation operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.hopping","page":"Operators","title":"DynamicalCorrelators.hopping","text":"hopping(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) hopping term\n\n\n\n\n\nhopping(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) hopping term\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.σz_hopping","page":"Operators","title":"DynamicalCorrelators.σz_hopping","text":"σz_hopping(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) σz hopping term\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.number","page":"Operators","title":"DynamicalCorrelators.number","text":"number(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) particle number operator\n\n\n\n\n\nnumber(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) particle number operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.onsiteCoulomb","page":"Operators","title":"DynamicalCorrelators.onsiteCoulomb","text":"onsiteCoulomb(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) onsite Coulomb interaction operator\n\n\n\n\n\nonsiteCoulomb(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) onsite Coulomb interaction operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#MPSKitModels.S_plus","page":"Operators","title":"MPSKitModels.S_plus","text":"S_plus(spin_symmetry::Type{<:Sector}, particle_symmetry::Type{<:Sector}; kwargs...)\nS_plus(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}; side=:L)\nfℤ₂ × SU(2) × U(1) spin operator (-S⁺/√2, Sᶻ, S⁻/√2)\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#MPSKitModels.S_min","page":"Operators","title":"MPSKitModels.S_min","text":"S_min(particle_symmetry::Type{<:Sector}, spin_symmetry::Type{<:Sector}; kwargs...)\nS_min(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}; side=:L)\nfℤ₂ × SU(2) × U(1) spin operator (-S⁻/√2, Sᶻ, S⁺/√2)\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#MPSKitModels.S_z","page":"Operators","title":"MPSKitModels.S_z","text":"S_z(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) Sᶻ operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.S_square","page":"Operators","title":"DynamicalCorrelators.S_square","text":"S_square(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep})\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.heisenberg","page":"Operators","title":"DynamicalCorrelators.heisenberg","text":"heisenberg(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) Heisenberg terms\n\n\n\n\n\nheisenberg(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) heisenberg term\n\n\n\n\n\nheisenberg(elt::Type{<:Number}, ::Type{SU2Irrep}; spin=1//2)\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.neiborCoulomb","page":"Operators","title":"DynamicalCorrelators.neiborCoulomb","text":"neiborCoulomb(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}, interspin::Bool; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) n↑n↓ terms between i and j sites\n\n\n\n\n\nneiborCoulomb(elt::Type{<:Number}, ::Type{SU2Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) n↑n↓ terms between i and j sites\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.spinflip","page":"Operators","title":"DynamicalCorrelators.spinflip","text":"spinflip(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) spinflip terms\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.pairhopping","page":"Operators","title":"DynamicalCorrelators.pairhopping","text":"pairhopping(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × U(1) × U(1) pairhopping terms\n\n\n\n\n\npairhopping(elt::Type{<:Number}, ::Type{U1Irrep}, ::Type{U1Irrep}; filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) pairhopping terms\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.singlet_dagger","page":"Operators","title":"DynamicalCorrelators.singlet_dagger","text":"singlet_dagger(elt::Type{<:Number}, spin_symmetry::Type{SU2Irrep}, particle_symmetry::Type{U1Irrep}; side=:L, filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) singlet creation operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.singlet","page":"Operators","title":"DynamicalCorrelators.singlet","text":"singlet(elt::Type{<:Number}, spin_symmetry::Type{SU2Irrep}, particle_symmetry::Type{U1Irrep}; side=:L, filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) singlet annihilation operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.triplet_dagger","page":"Operators","title":"DynamicalCorrelators.triplet_dagger","text":"triplet_dagger(elt::Type{<:Number}, spin_symmetry::Type{SU2Irrep}, particle_symmetry::Type{U1Irrep}; side=:L, filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) triplet creation operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.triplet","page":"Operators","title":"DynamicalCorrelators.triplet","text":"triplet(elt::Type{<:Number}, spin_symmetry::Type{SU2Irrep}, particle_symmetry::Type{U1Irrep}; side=:L, filling::NTuple{2, Integer}=(1,1))\nfℤ₂ × SU(2) × U(1) triplet annihilation operator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.chargedMPO","page":"Operators","title":"DynamicalCorrelators.chargedMPO","text":"chargedMPO(operator::AbstractTensorMap, site::Integer, nsites::Integer)\n\nConstruct a FiniteMPO that applies a single-site operator at position site on a chain of nsites sites. A fermionic string operator fZ (Jordan-Wigner string) is inserted on sites to the left or right of site depending on the operator leg structure:\n\n(1 codomain, 2 domain): creation-like → string on the left.\n(2 codomain, 1 domain): annihilation-like → string on the right.\n(1, 1): diagonal → identity everywhere else.\n\n\n\n\n\nchargedMPO(operator₁, operator₂, site₁, site₂, nsites)\n\nConstruct a FiniteMPO that applies two operators at positions site₁ < site₂. Requires operator₁ to be creation-like (1,2) and operator₂ to be annihilation-like (2,1). A Jordan-Wigner string is inserted between the two sites.\n\n\n\n\n\nchargedMPO(operator::AbstractTensorMap, site₁, site₂, nsites)\n\nConstruct a FiniteMPO for a two-site operator by decomposing it via SVD into local tensors at site₁ and site₂, with appropriate string operators in between. The decomposition handles creation-like, annihilation-like, and diagonal operators.\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#DynamicalCorrelators.identityMPO","page":"Operators","title":"DynamicalCorrelators.identityMPO","text":"identityMPO(H::FiniteMPOHamiltonian)\n\nConstruct an identity FiniteMPO compatible with Hamiltonian H. Each site is a BraidingTensor acting as an identity on the physical space.\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"api/observables/#Correlation-Types","page":"Observables","title":"Correlation Types","text":"","category":"section"},{"location":"api/observables/#Static-Correlators","page":"Observables","title":"Static Correlators","text":"","category":"section"},{"location":"api/observables/#Dynamical-Correlators","page":"Observables","title":"Dynamical Correlators","text":"","category":"section"},{"location":"api/observables/#Fourier-Transforms","page":"Observables","title":"Fourier Transforms","text":"","category":"section"},{"location":"api/observables/#Transport","page":"Observables","title":"Transport","text":"","category":"section"},{"location":"api/observables/#DynamicalCorrelators.AbstractCorrelation","page":"Observables","title":"DynamicalCorrelators.AbstractCorrelation","text":"abstract type AbstractCorrelation end\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#DynamicalCorrelators.PairCorrelation","page":"Observables","title":"DynamicalCorrelators.PairCorrelation","text":"PairCorrelation <: AbstractCorrelation\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#DynamicalCorrelators.TwoSiteCorrelation","page":"Observables","title":"DynamicalCorrelators.TwoSiteCorrelation","text":"TwoSiteCorrelation <: AbstractCorrelation\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#DynamicalCorrelators.OneSiteCorrelation","page":"Observables","title":"DynamicalCorrelators.OneSiteCorrelation","text":"OneSiteCorrelation <: AbstractCorrelation\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#DynamicalCorrelators.site_indices","page":"Observables","title":"DynamicalCorrelators.site_indices","text":"site_indices(latt::CustomLattice; a::Union{Nothing, Integer})\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#DynamicalCorrelators.pair_amplitude_indices","page":"Observables","title":"DynamicalCorrelators.pair_amplitude_indices","text":"pair_amplitude_indices(latt::CustomLattice, neighbors::Neighbors, a::Integer, b::Integer; amplitude::Union{Nothing, Function}=nothing, intralayer::Union{Nothing, Bool}=nothing)\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#MPSKit.correlator","page":"Observables","title":"MPSKit.correlator","text":"correlator(correlation::PairCorrelation, gs::AbstractFiniteMPS; is=Vector((length(correlation.lattice.lattice)÷2):-1:1), js=Vector((length(correlation.lattice.lattice)÷2+1):1:length(correlation.lattice.lattice)))\n\n\n\n\n\ncorrelator(correlation::TwoSiteCorrelation, gs::AbstractFiniteMPS; is=Vector((length(correlation.lattice.lattice)÷2):-1:1), js=Vector((length(correlation.lattice.lattice)÷2+1):1:length(correlation.lattice.lattice)))\n\n\n\n\n\ncorrelator(correlation::OneSiteCorrelation, gs::AbstractFiniteMPS; is=Vector((length(correlation.lattice.lattice)÷2):-1:1), js=Vector((length(correlation.lattice.lattice)÷2+1):1:length(correlation.lattice.lattice)))\n\n\n\n\n\ncorrelator(state::AbstractFiniteMPS, O::AbstractTensorMap, i::Integer)\n\n\n\n\n\ncorrelator(state::AbstractFiniteMPS, O₁::AbstractTensorMap, O₂::AbstractTensorMap, i::NTuple{1, Integer}, j::NTuple{1, Integer})\n\n\n\n\n\ncorrelator(state::AbstractFiniteMPS, O₁::AbstractTensorMap, O₂::AbstractTensorMap, ij::NTuple{2, Integer}, kl::NTuple{2, Integer})\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#DynamicalCorrelators.evolve_mps","page":"Observables","title":"DynamicalCorrelators.evolve_mps","text":"evolve_mps(H::MPOHamiltonian, ts::AbstractVector, rho_mps::FiniteMPS=convert(FiniteMPS, identityMPO(H)); \n                    filename::String=\"default_expiHt_ψ.jld2\", \n                save_id::AbstractArray=[length(ts),], \n                verbose::Bool=true, \n                n::Integer=3, \n                trscheme=truncerr(;rtol=1e-3),\n                tdvp1 = DefaultTDVP,\n                tdvp2 = DefaultTDVP2(trscheme)\n                )\n\n\n\n\n\nevolve_mps(H::Function, ts::AbstractVector, mus::AbstractVector, rho_mps::FiniteMPS=convert(FiniteMPS, identityMPO(H)); \n                    filename::String=\"default_expiHt_ψ.jld2\", \n                save_id::AbstractArray=[length(ts),], \n                verbose::Bool=true, \n                n::Integer=3, \n                trscheme=truncerr(;rtol=1e-3),\n                tdvp1 = DefaultTDVP,\n                tdvp2 = DefaultTDVP2(trscheme)\n                )\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#DynamicalCorrelators.dcorrelator","page":"Observables","title":"DynamicalCorrelators.dcorrelator","text":"dcorrelator(gs::FiniteNormalMPS, H::MPOHamiltonian, op::Union{AbstractTensorMap, AbstractArray{<:FiniteNormalMPS}}, indices::AbstractArray;\n                verbose=true, \n                gf_path::String=\"./\", \n                times::AbstractRange=0:0.05:5.0, \n                record_indices::AbstractArray=1:length(times),\n                n::Integer=3, \n                trscheme=truncerr(;rtol=1e-3),\n                tdvp1 = DefaultTDVP,\n                tdvp2 = DefaultTDVP2(trscheme)\n                )\nDynamical correlations in zero temperature\n\n\n\n\n\ndcorrelator(gs::FiniteNormalMPS, H::MPOHamiltonian, mps::AbstractVector{<:FiniteNormalMPS};\n                verbose=true, \n                gf_path::String=\"./\", \n                times::AbstractRange=0:0.05:5.0, \n                n::Integer=3, \n                trscheme=truncerr(;rtol=1e-3),\n                tdvp1 = DefaultTDVP,\n                tdvp2 = DefaultTDVP2(trscheme)\n                )\nDynamical correlations in zero temperature\n\n\n\n\n\ndcorrelator(rho::FiniteSuperMPS, H::MPOHamiltonian, op::AbstractTensorMap, indices::AbstractArray;\n                verbose=true, \n                gf_path::String=\"./\",   \n                times::AbstractRange=0:0.05:5.0, \n                beta::Union{Number, Missing}=missing,\n                n::Integer=3, \n                trscheme=truncerr(;rtol=1e-3),\n                tdvp1 = DefaultTDVP,\n                tdvp2 = DefaultTDVP2(trscheme)\n                )\nDynamical correlations in finite temperature\n\n\n\n\n\ndcorrelator(rho::FiniteSuperMPS, H::MPOHamiltonian, op::AbstractTensorMap, indices::AbstractArray;\n                verbose=true, \n                gf_path::String=\"./\",   \n                times::AbstractRange=0:0.05:5.0, \n                beta::Union{Number, Missing}=missing,\n                n::Integer=3, \n                trscheme=truncerr(;rtol=1e-3),\n                tdvp1 = DefaultTDVP,\n                tdvp2 = DefaultTDVP2(trscheme)\n                )\nDynamical correlations in finite temperature\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#DynamicalCorrelators.fourier_kw","page":"Observables","title":"DynamicalCorrelators.fourier_kw","text":"fourier_kw(gf_kt, ts, w, dampings)\n\nTime Fourier transform of G(k, t) to G(k, ω) at a single frequency w, with pre-computed damping factors.\n\n\n\n\n\nfourier_kw(gf_rt, rs, ts, ks, ws; mthreads=nthreads(), broadentype=(0.05, \"G\"), regroup=...)\n\nFull double Fourier transform from G(r, t) to G(k, ω) over arrays of momenta ks and frequencies ws. Multi-threaded over frequencies.\n\nArguments\n\ngf_rt: Green's function (N_sites, N_sites, N_times).\nrs: site position vectors.\nts: time range.\nks: array of momentum vectors.\nws: array of frequencies.\nmthreads: number of threads (default: all available).\nbroadentype: broadening specification, e.g., (0.05, \"G\") for Gaussian with η=0.05.\nregroup: orbital regrouping indices.\n\nReturns\n\nMatrix of shape (length(ws), length(ks)) containing G(k, ω)/(4π²).\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#DynamicalCorrelators.fourier_rw","page":"Observables","title":"DynamicalCorrelators.fourier_rw","text":"fourier_rw(gf_rt, ts, ws; broadentype=(0.05, \"G\"), mthreads=nthreads(), ifsum=true)\n\nTime Fourier transform from G(r, t) to G(r, ω) (real-space, frequency domain).\n\nArguments\n\ngf_rt: Green's function (N_sites, N_sites, N_times).\nts: time points.\nws: frequency points.\nbroadentype: broadening specification.\nmthreads: number of threads.\nifsum: if true, use simple summation; if false, use numerical integration.\n\nReturns\n\nArray of shape (N_sites, N_sites, length(ws)).\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#DynamicalCorrelators.static_structure_factor","page":"Observables","title":"DynamicalCorrelators.static_structure_factor","text":"static_structure_factor(ss, rs, ks)\n\nCompute the static structure factor S(k) from real-space correlations ss.\n\nS(mathbfk) = frac1N sum_ab langle S_a S_b rangle e^imathbfkcdot(mathbfr_a - mathbfr_b)\n\nArguments\n\nss: correlation matrix (N_sites, N_sites).\nrs: site position vectors.\nks: array of momentum vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#DynamicalCorrelators.conductivity","page":"Observables","title":"DynamicalCorrelators.conductivity","text":"conductivity(β, ∂Ek, Akw, ω_range; μ=0, ifsum=false)\n\nCompute the DC optical conductivity from the single-particle spectral function using the Kubo formula in the DMFT approximation.\n\nReference: A. Georges, G. Kotliar, W. Krauth, and M. J. Rozenberg, Dynamical Mean-Field Theory of Strongly Correlated Fermion Systems and the Limit of Infinite Dimensions, Rev. Mod. Phys. 68, 13 (1996).\n\nsigma = sum_k (partial E_k)^2 int domega  (-partial f(omega))  A^2(k omega)\n\nArguments\n\nβ: inverse temperature 1/T.\n∂Ek: array of band velocity (energy derivative) for each k-point.\nAkw: array of spectral functions A(k, ω) for each k-point (each element is a vector over ω).\nω_range: frequency grid.\nμ: chemical potential (default: 0).\nifsum: if true, use simple summation; if false, use numerical integration.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/finite_temperature/#Finite-Temperature-Calculations","page":"Finite Temperature","title":"Finite Temperature Calculations","text":"This tutorial covers finite-temperature dynamical correlations using the thermofield double (purification) approach.","category":"section"},{"location":"tutorials/finite_temperature/#Theory","page":"Finite Temperature","title":"Theory","text":"In the purification approach, the thermal density matrix rho = e^-beta H is represented as a pure state in a doubled Hilbert space (physical + ancilla):\n\nrhorangle = e^-beta H  2 mathbbIrangle\n\nwhere mathbbIrangle is the identity MPS (maximally entangled state between physical and ancilla spaces). This FiniteSuperMPS has 3 physical legs per site (virtual, physical, ancilla; virtual).","category":"section"},{"location":"tutorials/finite_temperature/#Workflow","page":"Finite Temperature","title":"Workflow","text":"","category":"section"},{"location":"tutorials/finite_temperature/#Step-1:-Construct-the-identity-MPS","page":"Finite Temperature","title":"Step 1: Construct the identity MPS","text":"using TensorKit, MPSKit, DynamicalCorrelators\n\nfilling = (1, 1)\nH = hubbard(Float64, SU2Irrep, U1Irrep, FiniteChain(12); t=1, U=8, filling=filling)\n\n# Create identity MPS (infinite temperature state)\nrho = identityMPS(H)","category":"section"},{"location":"tutorials/finite_temperature/#Step-2:-Evolve-to-finite-temperature","page":"Finite Temperature","title":"Step 2: Evolve to finite temperature","text":"Cool down to inverse temperature beta by evolving in imaginary time using TDVP (from MPSKit.jl):\n\nbeta = 2.0  # inverse temperature\nts_beta = 0:0.01:(beta/2)  # imaginary time steps (evolve β/2)\n\nrho_beta = evolve_mps(H, ts_beta, rho;\n    filename=\"rho_beta_$(beta).jld2\",\n    trscheme=truncrank(200),\n    n=3\n)","category":"section"},{"location":"tutorials/finite_temperature/#Step-3:-Compute-finite-T-correlations","page":"Finite Temperature","title":"Step 3: Compute finite-T correlations","text":"cp = e_plus(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\n\ngf = dcorrelator(rho_beta, H, cp, 1:length(H);\n    times=0:0.05:10,\n    beta=beta,\n    trscheme=truncrank(200)\n)","category":"section"},{"location":"tutorials/finite_temperature/#Key-differences-from-zero-temperature","page":"Finite Temperature","title":"Key differences from zero temperature","text":"MPS type: Uses FiniteSuperMPS (3-leg tensors) instead of FiniteNormalMPS (2-leg tensors).\nOperator application: The chargedMPS function handles the extra ancilla leg automatically.\nNormalization: The partition function Z = langlerhorhorangle is computed internally.\nTime evolution: Both the density matrix rho(t)rangle and the charged states need to be evolved.","category":"section"},{"location":"tutorials/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This tutorial covers the basic workflow for using DynamicalCorrelators.jl.","category":"section"},{"location":"tutorials/getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"Make sure you have the following packages installed:\n\nusing Pkg\nPkg.add(\"DynamicalCorrelators\")","category":"section"},{"location":"tutorials/getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"A typical calculation follows these steps:\n\nDefine a lattice — choose the geometry and boundary conditions\nBuild a Hamiltonian — specify the model parameters\nFind the ground state — using DMRG\nCompute observables — static/dynamical correlations, spectral functions","category":"section"},{"location":"tutorials/getting_started/#Step-1:-Lattice-Construction","page":"Getting Started","title":"Step 1: Lattice Construction","text":"","category":"section"},{"location":"tutorials/getting_started/#Using-pre-defined-lattices-from-MPSKitModels","page":"Getting Started","title":"Using pre-defined lattices from MPSKitModels","text":"For simple 1D chains:\n\nusing MPSKitModels: FiniteChain, InfiniteChain\n\nlattice = FiniteChain(48)   # 48-site open chain","category":"section"},{"location":"tutorials/getting_started/#Using-CustomLattice-for-2D-systems","page":"Getting Started","title":"Using CustomLattice for 2D systems","text":"For 2D systems, use the Square or BilayerSquare lattice types:\n\nusing DynamicalCorrelators\n\n# 4×4 square lattice with open boundaries\nsq = Square(4, 4)\n\n# 2×2 bilayer square lattice with 2 orbitals per site\nbl = BilayerSquare(2, 2; norbit=2)\n\n# Custom lattice from QuantumLattices\nusing QuantumLattices\nunitcell = Lattice([0.0, 0.0]; vectors=[[1, 0], [0, 1]])\nlattice = Lattice(unitcell, (4, 4), ('o', 'o'))\ncl = Custom(lattice)","category":"section"},{"location":"tutorials/getting_started/#Step-2:-Hamiltonian-Construction","page":"Getting Started","title":"Step 2: Hamiltonian Construction","text":"","category":"section"},{"location":"tutorials/getting_started/#Pre-defined-Hamiltonians-(with-non-Abelian-symmetry)","page":"Getting Started","title":"Pre-defined Hamiltonians (with non-Abelian symmetry)","text":"using TensorKit, MPSKit\n\nfilling = (1, 1)  # half-filling: P/Q = 1/1\n\n# SU(2)×U(1) Hubbard model on a chain\nH = hubbard(Float64, SU2Irrep, U1Irrep, FiniteChain(48);\n            t=1.0, U=8.0, μ=0.0, filling=filling)","category":"section"},{"location":"tutorials/getting_started/#From-QuantumLattices-(Abelian-symmetry-only)","page":"Getting Started","title":"From QuantumLattices (Abelian symmetry only)","text":"using QuantumLattices\n\nunitcell = Lattice([0.0, 0.0]; vectors=[[1, 0], [0, 1]])\nlattice = Lattice(unitcell, (4, 4), ('o', 'o'))\nhilbert = Hilbert(site => Fock{:f}(1, 2) for site in 1:length(lattice))\n\nt = Hopping(:t, -1.0, 1)\nU = Hubbard(:U, 8.0)\n\nH = hamiltonian((t, U), lattice, hilbert; neighbors=1)","category":"section"},{"location":"tutorials/getting_started/#Step-3:-Ground-State-Search","page":"Getting Started","title":"Step 3: Ground State Search","text":"# Create random initial MPS\nst = randFiniteMPS(ComplexF64, SU2Irrep, U1Irrep, 48; filling=filling)\n\n# Find ground state with DMRG\ngs, envs, delta = find_groundstate(st, H, DMRG2(trscheme=trunctol(1e-6)))\n\n# Check ground state energy\nE0 = expectation_value(gs, H)\nprintln(\"Ground state energy: \", E0)","category":"section"},{"location":"tutorials/getting_started/#Step-4:-Compute-Observables","page":"Getting Started","title":"Step 4: Compute Observables","text":"","category":"section"},{"location":"tutorials/getting_started/#Static-correlations","page":"Getting Started","title":"Static correlations","text":"# Spin-spin correlation\nsp = S_plus(Float64, SU2Irrep, U1Irrep; filling=filling)\ncorr = TwoSiteCorrelation((sp, sp), Custom(lattice), 1)\nFr = correlator(corr, gs)","category":"section"},{"location":"tutorials/getting_started/#Dynamical-correlations-(see-next-tutorials)","page":"Getting Started","title":"Dynamical correlations (see next tutorials)","text":"cp = e_plus(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\ncm = e_min(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\ngf = dcorrelator(gs, H, (cp, cm); times=0:0.05:10, trscheme=truncrank(200))","category":"section"},{"location":"tutorials/dynamical_correlations/#Dynamical-Correlations","page":"Dynamical Correlations","title":"Dynamical Correlations","text":"This tutorial explains how to compute dynamical correlation functions using TDVP time evolution (provided by MPSKit.jl).","category":"section"},{"location":"tutorials/dynamical_correlations/#Theory","page":"Dynamical Correlations","title":"Theory","text":"The retarded single-particle Green's function is defined as:\n\nG^R_ij(t) = -itheta(t)langle psi_0  c_i(t) c_j^dagger(0)  psi_0 rangle\n\nwhich can be decomposed into greater and lesser components:\n\nG^_ij(t) = -i e^iE_0 t langle psi_0  c_i  e^-iHt  c_j^dagger  psi_0 rangle\n\nThe key computational step is evolving the \"charged\" MPS c_j^daggerpsi_0rangle in time using TDVP, then computing overlaps with all langlepsi_0c_i at each time step.","category":"section"},{"location":"tutorials/dynamical_correlations/#Single-particle-Green's-function","page":"Dynamical Correlations","title":"Single-particle Green's function","text":"","category":"section"},{"location":"tutorials/dynamical_correlations/#Using-operator-pair-(c†,-c)","page":"Dynamical Correlations","title":"Using operator pair (c†, c)","text":"using TensorKit, MPSKit, DynamicalCorrelators\n\nfilling = (1, 1)\nH = hubbard(Float64, SU2Irrep, U1Irrep, FiniteChain(24); t=1, U=8, filling=filling)\nst = randFiniteMPS(ComplexF64, SU2Irrep, U1Irrep, 24; filling=filling)\ngs, _, _ = find_groundstate(st, H, DMRG2(trscheme=trunctol(1e-6)))\n\n# Define creation and annihilation operators\ncp = e_plus(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\ncm = e_min(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\n\n# Compute retarded Green's function G(r, t)\n# This evolves c†_j|gs⟩ and c_j|gs⟩ for all j, computing overlaps at each time step\ngf = dcorrelator(gs, H, (cp, cm);\n    times=0:0.05:20,        # time grid\n    trscheme=truncrank(200), # bond dimension control\n    n=3                      # use TDVP2 for first n steps, then TDVP1\n)","category":"section"},{"location":"tutorials/dynamical_correlations/#Using-pre-computed-charged-MPS","page":"Dynamical Correlations","title":"Using pre-computed charged MPS","text":"For large systems, you may want to pre-compute and store the charged MPS:\n\n# Pre-compute all c†_j|gs⟩\nmps = [chargedMPS(cp, gs, j) for j in 1:length(H)]\n\n# Then pass them directly\ngf = dcorrelator(gs, H, cp, 1:length(H);\n    times=0:0.05:20,\n    trscheme=truncrank(200)\n)","category":"section"},{"location":"tutorials/dynamical_correlations/#Spin-spin-dynamical-correlations","page":"Dynamical Correlations","title":"Spin-spin dynamical correlations","text":"For two-particle correlations like langle S^+(t) S^-(0) rangle:\n\nsp = S_plus(Float64, SU2Irrep, U1Irrep; filling=filling)\n\n# Compute spin dynamical structure factor\ngf_spin = dcorrelator(gs, H, sp, 1:length(H);\n    times=0:0.1:50,\n    trscheme=truncrank(200)\n)","category":"section"},{"location":"tutorials/dynamical_correlations/#Checkpoint-and-Resume","page":"Dynamical Correlations","title":"Checkpoint and Resume","text":"The dcorrelator function automatically saves intermediate results to JLD2 files in the gf_path directory. If a computation is interrupted, it will resume from the last saved checkpoint when re-run:\n\ngf = dcorrelator(gs, H, (cp, cm);\n    times=0:0.05:20,\n    gf_path=\"./green_functions/\",  # directory for checkpoints\n    trscheme=truncrank(200)\n)","category":"section"},{"location":"tutorials/dynamical_correlations/#TDVP-Algorithm-Selection","page":"Dynamical Correlations","title":"TDVP Algorithm Selection","text":"The parameter n controls the switch from two-site TDVP (TDVP2) to single-site TDVP (TDVP1):\n\nTDVP2 (first n steps): Allows bond dimension growth, more expensive but captures entanglement growth.\nTDVP1 (remaining steps): Fixed bond dimension, faster but may miss entanglement.\n\nFor typical calculations, n=2 or n=3 is sufficient.","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=\"./docs/src/logo.png\" width=\"200\">","category":"section"},{"location":"#DynamicalCorrelators.jl","page":"Home","title":"DynamicalCorrelators.jl","text":"A convenient frontend for calculating dynamical correlation functions and related observables based on matrix-product states time evolution methods.","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"The symbolic operator representation of a quantum lattice system in condensed matter physics is based on the package QuantumLattices\nThe  energy-minimization algorithms like DMRG and the time evolution methods such as TDVP are based on package MPSKit\nThe bechmark of dynamical correlation functions and related observables is the result from exact diagonalization method based on the packages ExactDiagonalization\n\nSee documents: https://zongyongyue.github.io/DynamicalCorrelators.jl","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Please type ] in the REPL to use the package mode, then type this command:\n\nadd DynamicalCorrelators","category":"section"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"Constuct a lattice by QuantumLattices:\n\nusing QuantumLattices\n#define the unitcell\nunitcell = Lattice([0.0, 0.0]; vectors=[[1/2, √3/2], [1, 0]])\n#give the length and width of the lattice and give the boundary condition where 'o' is open and 'p' is periodic\nlattice = Lattice(unitcell, (2, 2), ('o', 'o'))\nf = plot(lattice,1; siteon=true)\n\n\n<img  src=\"./docs/src/triangularlattice.png\"  width=\"400\"  align=\"center\" />\n\nWith the help of QuantumLattices, constructing the lattice of a realistic system allows for the convenient inclusion of terms in the Hamiltonian for arbitrary neighbors, without the need to construct different types of lattices and define their neighbor relations case by case:\n\nusing TensorKit\nusing MPSKit\nusing DynamicalCorrelators\nusing Plots\n#define the hilbert space\nhilbert = Hilbert(site=>Fock{:f}(1, 2) for site=1:length(lattice))\n\n#give the terms in the Hamiltonian\nt = Hopping(:t, -1.0, 1)\nU = Hubbard(:U, 8.0)\n\n#construct the Hamiltonian\nH = hamiltonian((t, U), lattice, hilbert; neighbors=1)\n\nHere, hamiltonian returns a MPOHamiltonian type data that can be directly used in the algorithms like DMRG in MPSKit:\n\n#give the filling = (a, b) -> filling = a/b\nfilling = (1, 1)\n\n#find the ground state and ground energy\nst = randFiniteMPS(Float64, U1Irrep, U1Irrep, length(lattice); filling=filling)\ngs, envs, delta = find_groundstate(st, H, DMRG2(trscheme= trunctol(1e-9)));\nE0 = expectation_value(gs, H)\n\nIt should be noted that currently, this construction method is only supported for Hamiltonians with Abelian symmetries. For Hamiltonians with non-Abelian symmetries, the construction still needs to follow the method used in MPSKitModels.\n\nNext, let's look at how to calculate correlation functions. Here, I consider SU(2) symmetry, so I use the pre-defined MPOHamiltonian in the models file. If only U(1) symmetry is considered, using the method described above to obtain the MPOHamiltonian provides greater flexibility.\n\nusing TensorKit\nusing MPSKit\nusing MPSKitModels: FiniteChain\nusing DynamicalCorrelators\n\n# give filling = (a,b), where a=b is half-filling, a<b is h-doping and a>b is e-doping\nfilling = (1,1)\n\n# give a hamiltonian\nN = 4\nH = hubbard(Float64, SU2Irrep, U1Irrep, FiniteChain(N); filling=filling, t=1, U=8, μ=0)\n\n# give a N-site random initial state\nst = randFiniteMPS(ComplexF64, SU2Irrep, U1Irrep, N; filling=filling)\n\n#find the ground state |gs>\ngs, envs, delta = find_groundstate(st, H, DMRG2(trscheme= trunctol(1e-6)));\n\n#obtain c^†_1|gs> and c^†_4|gs>\nep =  e_plus(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\ni, j = 1, 4\ncgs₁ = chargedMPS(ep, gs, i)\ncgs₂ = chargedMPS(ep, gs, j)\n\n\n#give the creation and annihilation operators\ncp =  e_plus(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\ncm =  e_min(Float64, SU2Irrep, U1Irrep; side=:L, filling=filling)\nsp =  S_plus(Float64, SU2Irrep, U1Irrep; filling=filling)\n\n#calculate the dynamical single-particle correlation function\nedc = dcorrelator(gs, H, (cp, cm); trscheme=truncrank(200), n=n, dt=dt, ft=ft)\n\n#calculate the dynamical two-particle spin-spin correlation function\nsdc = dcorrelator(gs, H, sp, 1:48; trscheme=truncrank(200), n=n, dt=dt, ft=ft)\n\nAfter Fourier transform with fourier_kw, we can obtain their spectral functions:\n\n<img  src=\"./docs/src/electron_spectrum.png\"  width=\"600\"  align=\"center\" />\n\nfor the electron spectrum, and\n\n<img  src=\"./docs/src/spin_spectrum.png\"  width=\"600\"  align=\"center\" />\n\nfor the spin-spin spectrum.","category":"section"},{"location":"#Dynamical-correlation-functions","page":"Home","title":"Dynamical correlation functions","text":"","category":"section"},{"location":"#Discrete-space-and-time-Fourier-transforms","page":"Home","title":"Discrete space and time Fourier transforms","text":"If the x variable has only discrete values (x=na, for n=123N) and finite length L (L=Na), the expansion of the function is\n\nf_n=sum_m=1^N A_q e^iq_m x_nquad q=frac2piLm\n\nwhere\n\nA_q=frac1Nsum^N_n=1f_n e^-iq_mx_n \n\nDividing A_q by the mode frac2piL the Fourier amplitudes with a per unit spacial interval is\n\n A(q) = fracL2piA_q=fraca2pisum^N_n=1f_ne^-iqx_n\n\nIf the times t are discrete times (t=lDelta t, for l=012N) and the final evolutionary time t_mathrmend=NDelta t, the expansion of the function is\n\n$\n\nfl=\\sum{p=1}^N A{\\omega} e^{-i\\omegap tl},\\quad \\omega=\\frac{2\\pi}{t{\\mathrm{end}}}p,$\n\nwhere\n\nA_omega=frac1Nsum_l=1^N f_l e^iomega_p t_l\n\nTo make it a per unit frequency interval, one need to divide by the spacing of the discrete frequency mode and the Fourier amlitudes are given by,\n\nA(omega)=fract_mathrmend2piA_omega=fracDelta t2pisum_l=1^N f_l e^iomega t_l\n\nAlthough a Fourier series is designed to represent functions that are periodic, one can assume that the finite data sequence can be periodically repeated, which leads to the time at index l=N is identified with the time at l=0. However, the small errors made at the end of a period will be irrelevant as long as the primary correlations decay in less time than t_mathrmend.","category":"section"},{"location":"#Space-and-time-correlations","page":"Home","title":"Space and time correlations","text":"By use of double Fourier transforms, one can obtain the k-omega space correlation function G(komega),\n\nG(komega)=frac1(2pi)^2Delta tsum_l=1^N_t asum_n=1^N_L G(x t) e^-i(kx-omega t)\n\nWith\n\nDelta t sum_l=1^N_tto int_0^t_mathrmenddtquad asum_n=1^N_Lto int_0^L dx\n\nthe continuous form is as follows\n\n$\n\nG(k,\\omega) = \\frac{1}{(2\\pi)^2} \\int0^{t{\\mathrm{end}}}dt \\int_0^L dx G(x, t) e^{-i(kx-\\omega t)}. $\n\nThe real-space and real-time correlation function G(x t) is given by,\n\n$\n\n\\begin{aligned}G\\left( x{n},t\\right) &=\\frac{1}{Nt}\\sum{l=1}^{Nt}\\frac{1}{N{L}}\\sum{m=1}^{N{L}}\\langle 0 | C\\left( x{m}+x{n},t{l}+t\\right) C^{\\dagger}\\left( x{m},t{l}\\right) | 0\\rangle \\\n&=\\frac{1}{Nt}\\sum{l=1}^{Nt}\\frac{1}{N{L}}\\sum{m=1}^{NL}\\langle 0| e^{iH(t{l}+t)}C\\left( x{m}+x{n}\\right) e^{-iH(tl+t) }e^{iHt{l}}C^{\\dagger}\\left( x{m}\\right) e^{-iHt{l}}| 0\\rangle \\\n&=\\frac{1}{N{L}}\\sum{m=1}^{N{L}}e^{iE{0}t}\\langle 0| C\\left( x{m}+x{n}\\right) e^{-iHt}C^{\\dagger}\\left( x{m}\\right) | 0\\rangle. \\end{aligned}$\n\nFinally, one gets,\n\n$\n\nG(k,\\omega)=\\frac{1}{(2\\pi)^2}\\Delta t\\sum{l=1}^{Nt} a\\sum{n=1}^{NL} \\frac{1}{N{L}}\\sum{m=1}^{N{L}}e^{iE{0}t}\\langle 0| C\\left( x{m}+x{n}\\right) e^{-iHt}C^{\\dagger}\\left( x{m}\\right) | 0\\rangle e^{-i(kxn-\\omega t)}. $\n\nHere, the matrix-product states time evolution methods are implemented to solve the state e^-iHtC^daggerleft( x_mright)  0rangle.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Wysin G M. Magnetic Excitations and Geometric Confinement[M]. Philadelphia, USA: IOP, 2015.\nPaeckel S, Köhler T, Swoboda A, et al. Time-evolution methods for matrix-product states[J]. Annals of Physics, 2019, 411: 167998.","category":"section"},{"location":"#Note","page":"Home","title":"Note","text":"Due to the fast development of this package, releases with different minor version numbers are not guaranteed to be compatible with previous ones before the release of v1.0.0. Comments are welcomed in the issues.","category":"section"},{"location":"#Contact","page":"Home","title":"Contact","text":"Y.-Y.Zong: zongyongyue@gmail.com","category":"section"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"We thank Maartenvd, lkdvos for help discussions, and thank Zhao-Long Gu for great help.","category":"section"},{"location":"api/algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"All core algorithms (DMRG, TDVP, IDMRG) are provided by MPSKit.jl. The functions below are convenience wrappers that add progress logging, automatic JLD2 file saving, and multi-sweep truncation management.","category":"section"},{"location":"api/algorithms/#DMRG","page":"Algorithms","title":"DMRG","text":"","category":"section"},{"location":"api/algorithms/#Infinite-DMRG","page":"Algorithms","title":"Infinite DMRG","text":"","category":"section"},{"location":"api/algorithms/#Default-Algorithm-Configurations","page":"Algorithms","title":"Default Algorithm Configurations","text":"","category":"section"},{"location":"api/algorithms/#Cluster-Perturbation-Theory-(CPT)","page":"Algorithms","title":"Cluster Perturbation Theory (CPT)","text":"","category":"section"},{"location":"api/algorithms/#DynamicalCorrelators.dmrg2!","page":"Algorithms","title":"DynamicalCorrelators.dmrg2!","text":"dmrg2!(ψ::AbstractFiniteMPS, H, truncdims::AbstractVector; alg::DMRG2=DefaultDMRG, filename::String=\"default_dmrg2.jld2\", verbose::Union{Bool, Integer}=true, envs=environments(ψ, H))\nAdd some auxiliary contents to `find_groundstate` in MPSKit.jl and rename the function as `dmrg2`.\n\n\n\n\n\n","category":"function"},{"location":"api/algorithms/#DynamicalCorrelators.dmrg2","page":"Algorithms","title":"DynamicalCorrelators.dmrg2","text":"dmrg2(ψ, H, truncdims; kwargs...)\n\nNon-mutating version of dmrg2!. Creates a copy of the MPS ψ before running the DMRG2 optimization.\n\n\n\n\n\n","category":"function"},{"location":"api/algorithms/#DynamicalCorrelators.dmrg2_sweep!","page":"Algorithms","title":"DynamicalCorrelators.dmrg2_sweep!","text":"dmrg2_sweep!(iter, ψ, H, trscheme, ϵs; alg=DefaultDMRG, filename=\"default_dmrg2.jld2\", verbose=true)\n\nPerform a single two-site DMRG sweep (left-to-right then right-to-left) on ψ. Wraps MPSKit's DMRG2 algorithm with progress logging, timing, and JLD2 checkpointing.\n\n\n\n\n\n","category":"function"},{"location":"api/algorithms/#DynamicalCorrelators.idmrg2","page":"Algorithms","title":"DynamicalCorrelators.idmrg2","text":"idmrg2(mps, operator, alg::alg_type; verbose::Union{Bool, Integer}=true, envs = environments(mps, operator)) where {alg_type <: Union{<:IDMRG, <:IDMRG2}}\nAdd some auxiliary contents to `find_groundstate` in MPSKit.jl and rename the function as `idmrg2`.\n\n\n\n\n\n","category":"function"},{"location":"api/algorithms/#DynamicalCorrelators.DefaultDMRG","page":"Algorithms","title":"DynamicalCorrelators.DefaultDMRG","text":"DefaultDMRG\n\nDefault DMRG2 algorithm configuration for ground-state optimization. Uses Lanczos eigensolver with krylovdim=3, LAPACK SVD, and bond dimension truncation at 4096.\n\n\n\n\n\n","category":"constant"},{"location":"api/algorithms/#DynamicalCorrelators.DefaultDMRG2","page":"Algorithms","title":"DynamicalCorrelators.DefaultDMRG2","text":"DefaultDMRG2(tol, krylovdim)\n\nConstruct a DMRG2 algorithm with custom eigensolver tolerance tol and Krylov dimension krylovdim. Other parameters are the same as DefaultDMRG.\n\n\n\n\n\n","category":"function"},{"location":"api/algorithms/#DynamicalCorrelators.DefaultTDVP","page":"Algorithms","title":"DynamicalCorrelators.DefaultTDVP","text":"DefaultTDVP\n\nDefault single-site TDVP algorithm configuration for time evolution. Uses Lanczos integrator with krylovdim=32 for accurate time-stepping.\n\n\n\n\n\n","category":"constant"},{"location":"api/algorithms/#DynamicalCorrelators.DefaultTDVP2","page":"Algorithms","title":"DynamicalCorrelators.DefaultTDVP2","text":"DefaultTDVP2(trscheme)\n\nConstruct a two-site TDVP algorithm with the given truncation scheme trscheme. Two-site TDVP allows bond dimension growth and is used for the first few time steps.\n\n\n\n\n\n","category":"function"},{"location":"api/algorithms/#DynamicalCorrelators.Perioder","page":"Algorithms","title":"DynamicalCorrelators.Perioder","text":"Perioder{P<:AbstractVector{<:Integer}, T<:AbstractArray{P}, S<:AbstractArray{P}, C<:AbstractVector{<:Tuple}}\n\nThe information needed in performing periodic procedure. \n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#DynamicalCorrelators.CPT","page":"Algorithms","title":"DynamicalCorrelators.CPT","text":"CPT{L<:QLattice, G<:EDSolver, P<:Perioder}\n\nCPT method for a quantum lattice system.\n\n\n\n\n\n","category":"type"},{"location":"api/algorithms/#DynamicalCorrelators.singleParticleGreenFunction","page":"Algorithms","title":"DynamicalCorrelators.singleParticleGreenFunction","text":"singleParticleGreenFunction(sym::Symbol, cpt::CPT, k_path::Union{AbstractVector, ReciprocalSpace}, ω_range::Union{AbstractVector,AbstractRange}; μ::Real=0.0,  dstr::Bool=false)\n\nThe single particle Green function in k-ω space.\n\n\n\n\n\n","category":"function"},{"location":"api/algorithms/#DynamicalCorrelators.spectrum","page":"Algorithms","title":"DynamicalCorrelators.spectrum","text":"spectrum(gfpathv::AbstractVector)\n\nThe spectrum of the single particle Green function.\n\n\n\n\n\n","category":"function"},{"location":"api/algorithms/#DynamicalCorrelators.densityofstates","page":"Algorithms","title":"DynamicalCorrelators.densityofstates","text":"Density of states\n\n\n\n\n\n","category":"function"}]
}
